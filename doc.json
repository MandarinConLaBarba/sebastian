[{"tags":[{"type":"param","types":["ctx"],"name":"","description":""}],"description":{"full":"<p>Set the execution context..useful when you need a context that's completely isolated from other execution contexts<br />flow.context() can be used to set execution context for all executions, but it is only shallow-cloned when<br />a new execution is created. Use this to set an execution-specific context</p>","summary":"<p>Set the execution context..useful when you need a context that's completely isolated from other execution contexts<br />flow.context() can be used to set execution context for all executions, but it is only shallow-cloned when<br />a new execution is created. Use this to set an execution-specific context</p>","body":""},"isPrivate":false,"ignore":false,"code":"execution.prototype.context = function(ctx) {\n        this.ctx = ctx;\n        return this;\n    };","ctx":{"type":"method","constructor":"execution","cons":"execution","name":"context","string":"execution.prototype.context()"},"params":[{"type":"param","types":["ctx"],"name":"","description":""}]},{"tags":[{"type":"returns","string":"{Deferred}"}],"description":{"full":"<p>Start/begin an execution. An execution is essentially an instance of a flow, with its own scope/context that<br />is isolated from other instances.</p>","summary":"<p>Start/begin an execution. An execution is essentially an instance of a flow, with its own scope/context that<br />is isolated from other instances.</p>","body":""},"isPrivate":false,"ignore":false,"code":"execution.prototype.execute = function() {","ctx":{"type":"method","constructor":"execution","cons":"execution","name":"execute","string":"execution.prototype.execute()"},"params":[]},{"tags":[{"type":"param","types":["Object"],"name":"arg1","description":"name of the step or a step callback (when no name is specified)"},{"type":"param","types":["Object"],"name":"arg2","description":"step callback/flow. If this is falsey and first arg is a string the function acts as a getter, otherwise it's a setter"},{"type":"api","visibility":"public"},{"type":"return","types":["mixed"],"description":"Flow or step"}],"description":{"full":"<p>Get or set a step.</p>\n\n<p>Basic usage:</p>\n\n<ul>\n<li><code>flow.step(name, callback);</code></li>\n</ul>\n\n<p>Overloads:</p>\n\n<ul>\n<li><code>flow.step(callback);</code></li>\n<li><code>flow.step(name, flow);</code></li>\n<li><code>flow.step(flow);</code></li>\n</ul>","summary":"<p>Get or set a step.</p>","body":"<p>Basic usage:</p>\n\n<ul>\n<li><code>flow.step(name, callback);</code></li>\n</ul>\n\n<p>Overloads:</p>\n\n<ul>\n<li><code>flow.step(callback);</code></li>\n<li><code>flow.step(name, flow);</code></li>\n<li><code>flow.step(flow);</code></li>\n</ul>"},"isPrivate":false,"ignore":false,"code":"flow.prototype.step = function(arg1, arg2) {\n\n        var self = this,\n            wrapFlowCallback = function(flow) {\n                return function() {\n                    return flow.context(this).begin.apply(flow, [].slice.call(arguments));\n                };\n            };\n\n        //Check if second arg is present, if so add/create step object with explicit name\n        if (arg2) {\n            if (typeof arg2 === \"string\") {\n                arg2 = Flow(arg2);\n            }\n            this.steps.push({\n                name : arg1,\n                callback : arg2.flow ? wrapFlowCallback(arg2) : arg2 //if callback is a flow, create a flow wrapper callback\n            });\n            return this;\n        } else if (typeof arg1 === \"function\"){\n            //If first arg is a function, make up a name for them\n            this.steps.push({\n                name : \"step.\" + (this.steps.length + 1),\n                callback : arg1\n            });\n            return this;\n        } else if (typeof arg1 === \"object\" && arg1.flow) {\n            //If first arg is an object, make up a name for them and create a flow wrapper callback\n            this.steps.push({\n                name : \"step.\" + (this.steps.length + 1) + \".\" + arg1.name,\n                callback : wrapFlowCallback(arg1)\n            });\n            return this;\n        } else {\n            var foundStep;\n            for (var i = 0; i < this.steps.length; i++)\n            {\n                if (self.steps[i].name === arg1) {\n                    foundStep = self.steps[i];\n                    break;\n                }\n\n            }\n            return foundStep;\n        }\n\n    };","ctx":{"type":"method","constructor":"flow","cons":"flow","name":"step","string":"flow.prototype.step()"},"params":[{"type":"param","types":["Object"],"name":"arg1","description":"name of the step or a step callback (when no name is specified)"},{"type":"param","types":["Object"],"name":"arg2","description":"step callback/flow. If this is falsey and first arg is a string the function acts as a getter, otherwise it's a setter"}]},{"tags":[{"type":"return","types":["Flow"],"description":""}],"description":{"full":"<p>Set flow to execute all steps in parallel</p>\n\n<p>Usage:</p>\n\n<ul>\n<li><code>flow.parallel()</code></li>\n</ul>","summary":"<p>Set flow to execute all steps in parallel</p>","body":"<p>Usage:</p>\n\n<ul>\n<li><code>flow.parallel()</code></li>\n</ul>"},"isPrivate":false,"ignore":false,"code":"flow.prototype.parallel = function() {\n        this.mode = \"parallel\";\n        return this;\n    };","ctx":{"type":"method","constructor":"flow","cons":"flow","name":"parallel","string":"flow.prototype.parallel()"},"params":[]},{"tags":[{"type":"return","types":["Flow"],"description":""}],"description":{"full":"<p>Set flow to execute steps in sequence, passing results from upstream step as argument to downstream step</p>\n\n<p>Usage:</p>\n\n<ul>\n<li><code>flow.waterfall()</code></li>\n</ul>","summary":"<p>Set flow to execute steps in sequence, passing results from upstream step as argument to downstream step</p>","body":"<p>Usage:</p>\n\n<ul>\n<li><code>flow.waterfall()</code></li>\n</ul>"},"isPrivate":false,"ignore":false,"code":"flow.prototype.waterfall = function() {\n        this.mode = \"waterfall\";\n        return this;\n    };","ctx":{"type":"method","constructor":"flow","cons":"flow","name":"waterfall","string":"flow.prototype.waterfall()"},"params":[]},{"tags":[{"type":"return","types":["Flow"],"description":""}],"description":{"full":"<p>Begin the flow. All arguments are passed on to either first step (waterfall) or all steps (parallel).</p>\n\n<p>Basic usage:</p>\n\n<ul>\n<li><code>flow.begin()</code></li>\n</ul>\n\n<p>Overloads:</p>\n\n<ul>\n<li><code>flow.begin(arg1, arg2, arg3, ...);</code></li>\n</ul>","summary":"<p>Begin the flow. All arguments are passed on to either first step (waterfall) or all steps (parallel).</p>","body":"<p>Basic usage:</p>\n\n<ul>\n<li><code>flow.begin()</code></li>\n</ul>\n\n<p>Overloads:</p>\n\n<ul>\n<li><code>flow.begin(arg1, arg2, arg3, ...);</code></li>\n</ul>"},"isPrivate":false,"ignore":false,"code":"flow.prototype.begin = function() {\n\n        var exe = new execution(this);\n\n        return exe.execute.apply(exe, [].slice.call(arguments));\n\n    };","ctx":{"type":"method","constructor":"flow","cons":"flow","name":"begin","string":"flow.prototype.begin()"},"params":[]},{"tags":[{"type":"returns","string":"{execution}"}],"description":{"full":"<p>Create a new execution, but don't start it, just return. Useful for setting context on the execution when you need isolation.</p>\n\n<p>e.g.:</p>\n\n<div class=\"highlight\"><pre lang=\"\">var execution = flow.create();\nexecution.context({ some : \"value\"});\nexecution.execute();\n</pre></div>","summary":"<p>Create a new execution, but don't start it, just return. Useful for setting context on the execution when you need isolation.</p>","body":"<p>e.g.:</p>\n\n<div class=\"highlight\"><pre lang=\"\">var execution = flow.create();\nexecution.context({ some : \"value\"});\nexecution.execute();\n</pre></div>"},"isPrivate":false,"ignore":false,"code":"flow.prototype.create = function() {\n\n        return new execution(this);\n\n    };","ctx":{"type":"method","constructor":"flow","cons":"flow","name":"create","string":"flow.prototype.create()"},"params":[]},{"tags":[{"type":"param","types":["Object"],"name":"context","description":"the context object for the flow"},{"type":"return","types":["Flow"],"description":"flow"}],"description":{"full":"<p>Specify the 'this' context for the flow</p>\n\n<p>Usage :</p>\n\n<ul>\n<li><code>flow.context(object);</code></li>\n</ul>","summary":"<p>Specify the 'this' context for the flow</p>","body":"<p>Usage :</p>\n\n<ul>\n<li><code>flow.context(object);</code></li>\n</ul>"},"isPrivate":false,"ignore":false,"code":"flow.prototype.context = function(context) {\n        this.ctx = context;\n        return this;\n    };","ctx":{"type":"method","constructor":"flow","cons":"flow","name":"context","string":"flow.prototype.context()"},"params":[{"type":"param","types":["Object"],"name":"context","description":"the context object for the flow"}]},{"tags":[{"type":"param","types":["String"],"name":"name","description":"name of the step to skip"},{"type":"return","types":["Flow"],"description":"flow"}],"description":{"full":"<p>Specify a step to start the flow on</p>\n\n<p>Usage:</p>\n\n<ul>\n<li><code>flow.startOn(stepName);</code></li>\n</ul>","summary":"<p>Specify a step to start the flow on</p>","body":"<p>Usage:</p>\n\n<ul>\n<li><code>flow.startOn(stepName);</code></li>\n</ul>"},"isPrivate":false,"ignore":false,"code":"flow.prototype.startOn = function(name) {\n        this.startingStep = name;\n        return this;\n    };","ctx":{"type":"method","constructor":"flow","cons":"flow","name":"startOn","string":"flow.prototype.startOn()"},"params":[{"type":"param","types":["String"],"name":"name","description":"name of the step to skip"}]},{"tags":[{"type":"returns","string":"{Flow}"}],"description":{"full":"<p>Set the flow to only run one time...always returning the promise from the first execution.</p>","summary":"<p>Set the flow to only run one time...always returning the promise from the first execution.</p>","body":""},"isPrivate":false,"ignore":false,"code":"flow.prototype.once = function() {\n        this.runOnce = true;\n        return this;\n    };","ctx":{"type":"method","constructor":"flow","cons":"flow","name":"once","string":"flow.prototype.once()"},"params":[]},{"tags":[{"type":"param","types":["String"],"name":"name","description":"name of the step to skip"},{"type":"return","types":["Flow"],"description":"Flow"}],"description":{"full":"<p>Specify a step to skip</p>\n\n<p>Usage:</p>\n\n<ul>\n<li><code>flow.skip(stepName);</code></li>\n</ul>","summary":"<p>Specify a step to skip</p>","body":"<p>Usage:</p>\n\n<ul>\n<li><code>flow.skip(stepName);</code></li>\n</ul>"},"isPrivate":false,"ignore":false,"code":"flow.prototype.skip = function(name) {\n        this.skipSteps.push(name);\n        return this;\n    };","ctx":{"type":"method","constructor":"flow","cons":"flow","name":"skip","string":"flow.prototype.skip()"},"params":[{"type":"param","types":["String"],"name":"name","description":"name of the step to skip"}]},{"tags":[{"type":"param","types":["Number"],"name":"ms","description":"milliseconds to delay"},{"type":"return","types":["Flow"],"description":""}],"description":{"full":"<p>Add a delay after execution of step added last</p>","summary":"<p>Add a delay after execution of step added last</p>","body":""},"isPrivate":false,"ignore":false,"code":"flow.prototype.delay = function(ms) {\n\n        var last = this.steps[this.steps.length - 1];\n\n        this.step(last.name + \"-delay\", function() {\n            var deferred = $.Deferred();\n\n            setTimeout(deferred.resolve, ms);\n\n            return deferred;\n        });\n\n        return this;\n\n    };","ctx":{"type":"method","constructor":"flow","cons":"flow","name":"delay","string":"flow.prototype.delay()"},"params":[{"type":"param","types":["Number"],"name":"ms","description":"milliseconds to delay"}]},{"tags":[{"type":"param","types":["Function"],"name":"callback","description":"the callback to execute on failure"},{"type":"return","types":["Flow"],"description":""}],"description":{"full":"<p>Handle failure with a callback</p>\n\n<p>Usage:</p>\n\n<ul>\n<li><code>flow.onFailure().handleWith(callback);</code></li>\n<li><code>flow.onFailure(responseCode).handleWith(callback);</code></li>\n</ul>","summary":"<p>Handle failure with a callback</p>","body":"<p>Usage:</p>\n\n<ul>\n<li><code>flow.onFailure().handleWith(callback);</code></li>\n<li><code>flow.onFailure(responseCode).handleWith(callback);</code></li>\n</ul>"},"isPrivate":false,"ignore":false,"code":"onFailureOptions.handleWith = function(callback) {\n            if (responseCode) {\n                self.conditionalFailCallbacks[responseCode] = callback;\n            } else {\n                self.defaultFailCallback = callback;\n            }\n\n            return self;\n        };","ctx":{"type":"method","receiver":"onFailureOptions","name":"onFailure().handleWith","string":"onFailureOptions.handleWith()"},"params":[{"type":"param","types":["Function"],"name":"callback","description":"the callback to execute on failure"}]},{"tags":[{"type":"return","types":["Flow"],"description":"flow"}],"description":{"full":"<p>Handle failure by starting the flow over</p>\n\n<p>Usage:</p>\n\n<ul>\n<li><code>flow.onFailure().loop();</code></li>\n<li><code>flow.onFailure(responseCode).loop();</code></li>\n</ul>","summary":"<p>Handle failure by starting the flow over</p>","body":"<p>Usage:</p>\n\n<ul>\n<li><code>flow.onFailure().loop();</code></li>\n<li><code>flow.onFailure(responseCode).loop();</code></li>\n</ul>"},"isPrivate":false,"ignore":false,"code":"onFailureOptions.loop = function() {\n            return storeDelegate(self);\n        };","ctx":{"type":"method","receiver":"onFailureOptions","name":"onFailure().loop","string":"onFailureOptions.loop()"},"params":[]},{"tags":[{"type":"param","types":["Flow"],"name":"flow","description":"the flow to delegate to on failure"},{"type":"return","types":["Flow"],"description":"flow"}],"description":{"full":"<p>Handle failure by jumping to another flow</p>\n\n<p>Usage:</p>\n\n<ul>\n<li><code>flow.onFailure().jumpTo(flow);</code></li>\n<li><code>flow.onFailure(responseCode).jumpTo(flow);</code></li>\n</ul>","summary":"<p>Handle failure by jumping to another flow</p>","body":"<p>Usage:</p>\n\n<ul>\n<li><code>flow.onFailure().jumpTo(flow);</code></li>\n<li><code>flow.onFailure(responseCode).jumpTo(flow);</code></li>\n</ul>"},"isPrivate":false,"ignore":false,"code":"onFailureOptions.jumpTo = function(flow) {\n            return storeDelegate(flow);\n        };\n\n        return onFailureOptions;\n\n    };","ctx":{"type":"method","receiver":"onFailureOptions","name":"onFailure().jumpTo","string":"onFailureOptions.jumpTo()"},"params":[{"type":"param","types":["Flow"],"name":"flow","description":"the flow to delegate to on failure"}]},{"tags":[{"type":"param","types":["Flow"],"name":"flow","description":"the flow to delegate to on success"},{"type":"return","types":["Flow"],"description":"flow"}],"description":{"full":"<p>Handle Success by jumping to another flow</p>\n\n<p>Usage:</p>\n\n<ul>\n<li><code>flow.onSuccess().jumpTo(flow);</code></li>\n</ul>","summary":"<p>Handle Success by jumping to another flow</p>","body":"<p>Usage:</p>\n\n<ul>\n<li><code>flow.onSuccess().jumpTo(flow);</code></li>\n</ul>"},"isPrivate":false,"ignore":false,"code":"onSuccessOptions.jumpTo = function(flow) {\n            self.defaultSuccessDelegate = flow;\n            return self;\n        };","ctx":{"type":"method","receiver":"onSuccessOptions","name":"onSuccess().jumpTo","string":"onSuccessOptions.jumpTo()"},"params":[{"type":"param","types":["Flow"],"name":"flow","description":"the flow to delegate to on success"}]},{"tags":[],"description":{"full":"<p>Handle success by starting the flow over</p>","summary":"<p>Handle success by starting the flow over</p>","body":""},"ignore":false,"code":"onSuccessOptions.loop = function() {\n            self.defaultSuccessDelegate = self;\n            return self;\n        };\n\n        return onSuccessOptions;\n    };","ctx":{"type":"method","receiver":"onSuccessOptions","name":"onSuccess().loop","string":"onSuccessOptions.loop()"},"params":[]},{"tags":[],"description":{"full":"<p>Alias for onSuccess().loop()</p>","summary":"<p>Alias for onSuccess().loop()</p>","body":""},"ignore":false,"code":"flow.prototype.loop = function() {\n\n        this.onSuccess().loop();\n        return this;\n\n    };","ctx":{"type":"method","constructor":"flow","cons":"flow","name":"loop","string":"flow.prototype.loop()"},"params":[]}]